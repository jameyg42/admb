const EMPTY = Promise.resolve([]);
function none(context:AdmbCompletionContext):Promise<Completion[]> {
  return EMPTY;
}
function ifExplicit(source:AdmbCompletionSource):AdmbCompletionSource {
  return (context:AdmbCompletionContext, provider:CompletionProvider) => context.original.explicit ? source(context, provider) : EMPTY;
}
function merged(...sources:AdmbCompletionSource[]):AdmbCompletionSource {
  return (context:AdmbCompletionContext, provider:CompletionProvider) => Promise.all(sources.map(source => source(context, provider)))
    .then(results => results
        .filter(r => r)
        .flatMap(r => r)
    )
}

function charAt(context:CompletionContext, pos:number):string {
   if (pos == 0) return '';
   return context.state.sliceDoc(pos-1, pos);
 }

 function findParent(node:SyntaxNode|null, named:string):SyntaxNode|null {
   while (node && named != node.name) {
     node = node.parent;
   }
   return node;
 }
 function text(node:SyntaxNode|null|undefined, context:CompletionContext):string|null {
   if (!node) return null;
   return context.state.sliceDoc(node.from, node.to);
 } 